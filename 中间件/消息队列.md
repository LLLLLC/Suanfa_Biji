# 1.消息队列基础

## 1.1 基本概述

### 1.1.1 什么是消息队列？



### 1.1.2 消息队列有哪些？

当前使用较多的消息队列有`RabbitMQ`、`RocketMQ`、`ActiveMQ`、`Kafka`、`ZeroMQ`、`MetaMq`等，而部分数据库如`Redis`、`Mysql`以及`phxsql`也可实现消息队列的功能。

### 1.1.3 消息队列要解决引用场景有哪些？

主要的应用场景有三大应用场景：

**异步通信**

用下面一个例子来说明异步通信的情况：

我们之前的场景里面有很多步骤都是在一个流程里面需要做完的，就比如说我的下单系统吧，本来我们业务简单，下单了付了钱就好了，流程就走完了。

但是后面来了个产品经理，搞了个**优惠券系统**，OK问题不大，流程里面多100ms去扣减优惠券。

后来产品经理灵光一闪说我们可以搞个**积分系统**啊，也行吧，流程里面多了200ms去增减积分。

再后来后来隔壁的产品老王说：下单成功后我们要给用户发短信，也将就吧，100ms去发个短信。

<img src="../Java学习/images/v2-78d930cb32bdde2112c5c0e70ddb1487_1440w.jpg" alt="v2-78d930cb32bdde2112c5c0e70ddb1487_1440w.jpg" style="zoom: 100%;" />

通过异步的方式来解决该问题

<img src="../Java学习/images/v2-f0f03f80551dabb7ba60367c25e4fb01_1440w.jpg" alt="v2-f0f03f80551dabb7ba60367c25e4fb01_1440w.jpg" style="zoom: 100%;" />

**系统解耦**

这里解耦其实暗含为什么不用线程来完成上述异步通信的工作。

为啥我们不能用线程去做，因为用线程去做，你是不是要写代码？

你一个订单流程，你扣积分，扣优惠券，发短信，扣库存。。。等等这么多业务要调用这么多的接口，**每次加一个你要调用一个接口然后还要重新发布系统**，写一次两次还好，写多了你就说：老子不干了

而且真的全部都写在一起的话，不单单是耦合这一个问题，你出问题排查也麻烦，流程里面随便一个地方出问题搞不好会影响到其他的点，小伙伴说我每个流程都**try catch**不就行了，相信我别这么做，这样的代码就像个**定时炸弹** ，你不知道什么时候爆炸，平时不炸偏偏在你做活动的时候炸，你就领个**P0故障**收拾书包**提前回家过年**吧。

你下单了，你就把你**支付成功的消息告诉别的系统**，他们收到了去处理就好了，你只用走完自己的流程，把自己的消息发出去，那后面要接入什么系统简单，直接订阅你发送的支付成功消息，你支付成功了我**监听就好了**。

<img src="../Java学习/images/v2-ee2ed0c6889e4f1f157010745dd0f162_1440w.jpg" alt="v2-ee2ed0c6889e4f1f157010745dd0f162_1440w.jpg" style="zoom: 100%;" />

**那你的流程走完了，你不用管别人是否成功么？比如你下单了积分没加，优惠券没扣怎么办？** 

问题是个好问题，但是没必要考虑，业务系统本身就是自己的开发人员维护的，你积分扣失败关我下单的什么事情？你管好自己下单系统的就好了。

**Tip**：话是这么说，但是这其实是用了消息队列的一个缺点，涉及到**分布式事务**的知识点，我下面会提到。

**流量削峰**

就拿秒杀来说，你平时流量很低，但是你要做秒杀活动00 ：00的时候流量疯狂怼进来，你的服务器，**Redis**，**MySQL**各自的承受能力都不一样，你直接**全部流量照单全收**肯定有问题啊，直接就打挂了。

简单，把请求放到队列里面，然后至于每秒消费多少请求，就看自己的**服务器处理能力**，你能处理5000QPS你就消费这么多，可能会比正常的慢一点，但是**不至于打挂服务器**，等流量高峰下去了，你的服务也就没压力了。

### 1.1.4 消息队列的模型有哪些？

> 一种是队列模式，一种是基于订阅和发布的机制。

#### **队列模型**

最初的消息队列就是上一节讲的原始模型，它是一个严格意义上的队列（Queue）。消息按照什么顺序写进去，就按照什么顺序读出来。不过，队列没有 “读” 这个操作，读就是出队，从队头中 “删除” 这个消息。

<img src="../Java学习/images/v2-7dfb814e3963cb9cdfdada13f64c703a_1440w.jpg" alt="v2-7dfb814e3963cb9cdfdada13f64c703a_1440w.jpg" style="zoom: 67%;" />

这便是队列模型：它允许多个生产者往同一个队列发送消息。但是，如果有多个消费者，实际上是竞争的关系，也就是一条消息只能被其中一个消费者接收到，读完即被删除。

#### **发布-订阅模型**

如果需要将一份消息数据分发给多个消费者，并且每个消费者都要求收到全量的消息。很显然，队列模型无法满足这个需求。

一个可行的方案是：为每个消费者创建一个单独的队列，让生产者发送多份。这种做法比较笨，而且同一份数据会被复制多份，也很浪费空间。

为了解决这个问题，就演化出了另外一种消息模型：发布-订阅模型

<img src="../Java学习/images/v2-b05d98e0c85c49fe366ff7f159f6fa91_1440w.jpg" alt="v2-b05d98e0c85c49fe366ff7f159f6fa91_1440w.jpg" style="zoom: 67%;" />

在发布-订阅模型中，存放消息的容器变成了 “主题”，订阅者在接收消息之前需要先 “订阅主题”。最终，每个订阅者都可以收到同一个主题的全量消息。

仔细对比下它和 “队列模式” 的异同：生产者就是发布者，队列就是主题，消费者就是订阅者，无本质区别。唯一的不同点在于：一份消息数据是否可以被多次消费。

### 1.1.5 AMQP 模型的三大组件 ：

- **交换器 (Exchange)** ：消息代理服务器中用于把消息路由到队列的组件。
- **队列 (Queue)** ：用来存储消息的数据结构，位于硬盘或内存中。
- **绑定 (Binding)** ：一套规则，告知交换器消息应该将消息投递给哪个队列。

### 1.1.6 AMQP 协议的三层 ：

- **Module Layer**:协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。
- **Session Layer**:中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。
- **TransportLayer**:最底层，主要传输二进制数据流，提供帧的处理、信道服用、错误检测和数据表示等。

## 1.2 消息队列 Exchange类型

- fanout (广播类型)
- direct (完全匹配)
- topic (正则匹配)
- headers (头信息匹配)

##  1.3 RabbitMQ 有哪些工作模式？

- 简单模式
- work 工作模式
- pub/sub 发布订阅模式
- Routing 路由模式
- Topic 主题模式

## 1.4  如何保证消息的可靠性

消息到 MQ 的过程中搞丢，MQ 自己搞丢，MQ 到消费过程中搞丢。

- 生产者到 RabbitMQ：事务机制和 Confirm 机制，注意：事务机制和 Confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。
- RabbitMQ 自身：持久化、集群、普通模式、镜像模式。
- RabbitMQ 到消费者：basicAck 机制、死信队列、消息补偿机制。

##  1.5 如何保证 RabbitMQ 消息的顺序性？

- 拆分多个 queue(消息队列)，每个 queue(消息队列) 一个 consumer(消费者)，就是多一些 queue (消息队列)而已，确实是麻烦点；
- 或者就一个 queue (消息队列)但是对应一个 consumer(消费者)，然后这个 consumer(消费者)内部用内存队列做排队，然后分发给底层不同的 worker 来处理。

## 1.6 如何保证 RabbitMQ 高可用的？

## 1.7  如何解决消息挤压问题？

## 1.8  如何解决消息队列的延时以及过期失效问题？

# 2.  死信队列

DLX，全称为 `Dead-Letter-Exchange`，死信交换器，死信邮箱。当消息在一个队列中变成死信 (`dead message`) 之后，它能被重新被发送到另一个交换器中，这个交换器就是 DLX，绑定 DLX 的队列就称之为死信队列。

## 2.1 导致的死信的几种原因：

- 消息被拒（`Basic.Reject /Basic.Nack`) 且 `requeue = false`。
- 消息 TTL 过期。
- 队列满了，无法再添加。

# 3. 延时队列

延迟队列指的是存储对应的延迟消息，消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。

RabbitMQ本身是没有延迟队列的，要实现延迟消息，一般有两种方式：

1. 通过RabbitMQ本身队列的特性来实现，需要使用RabbitMQ的死信交换机（Exchange）和消息的存活时间TTL（Time To Live）。
2. 在RabbitMQ 3.5.7及以上的版本提供了一个插件（rabbitmq-delayed-message-exchange）来实现延迟队列功能。同时，插件依赖Erlang/OPT 18.0及以上。

也就是说，AMQP 协议以及RabbitMQ本身没有直接支持延迟队列的功能，但是可以通过TTL和DLX模拟出延迟队列的功能。

> 过期时间
>
> 死信路由

