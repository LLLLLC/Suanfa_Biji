# 1. 并发基础

## 1.1 多线程基础

为什么要使用多线程?

- 单核 CPU，发生 IO时，单线程 CPU 会等待IO操作
- 多核 CPU，需要多线程来映射CPU核心
- 此外，程序需要多线程工作，比如 一个线程听歌，一个线程UI界面，一个线程监听输入等

使用多线程会带来的问题？

> - 死锁
> - 不安全访问
> - 内存泄漏等

## 1.2 线程状态

Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：

- NEW: 初始状态，线程被创建出来但没有被调用 `start()` 。
- RUNNABLE: 运行状态，线程被调用了 `start()`等待运行的状态。
- BLOCKED：阻塞状态，需要等待锁释放。
- WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。
- TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。
- TERMINATED：终止状态，表示该线程已经运行完毕。

> 基本状态如下：
>
> 初始 - > 运行
>
> 运行 -> 包括 运行和就绪
>
> 阻塞 -> 运行 等待锁的释放
>
> 等待 -> 运行 wait方法
>
> 超时等待 -> 运行 sleep方法
>
> 销毁

<img src="..\images\640.png" style="zoom:50%;" />

**sleep() 方法会释放锁吗？**

sleep 不释放锁，wait 方法释放锁

## 1.3 死锁

死锁的必要条件：

- 互斥条件：该资源任意一个时刻只由一个线程占用。
- 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
- 循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系

**如何预防死锁？** 破坏死锁的产生的必要条件即可：

1. **破坏请求与保持条件**：一次性申请所有的资源。
2. **破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
3. **破坏循环等待条件**：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

> 一次性申请所有的资源，申请不到就释放到占有的资源，按顺序获得资源

## 1.4 join wait sleep yeild

这几个方法会释放当前线程的吗？

- `Thread.sleep()` 不会释放锁
- `Thread.yield()` 不会释放锁，只是释放时间片
- `t.join()/t.join(long millis)` 不会释放锁
- `obj.wait()` 释放对象锁，需要 notify 来唤醒

## 1.5 yeild

> yeild 有什么用？
>
> 让出当前CPU的时间片，回到就绪态，并尝试重新抢占CPU
>
> 目前在网上看到用途比较少，基本没有，可能为了避免一个线程长时间占据CPU资源，如果一个线程在执行长时间CPU操作的时候，可以防止线程长期占据CPU

**yield 和 sleep 的异同**

1. yield, sleep 都能暂停当前线程，sleep 可以指定具体休眠的时间，而 yield 则依赖 CPU 的时间片划分。
2. yield, sleep 两个在暂停过程中，如已经持有锁，则都不会释放锁资源。
3. yield 不能被中断，而 sleep 则可以接受中断。

# 2. 并发进阶

## 2.1 `ThreadLocal` 

## 2.2 AQS 及其衍生

AQS 内容已经说明了，这里主要说基于AQS的工具类

> AQS 的底层原理是什么？
>
> CAS + CLH 双向链表队列

说一下 AQS 常见的衍生同步类：

> `Semaphore`  ,  `CountDownLatch`, `CyclicBarrier` 
>
> Semaphore 将 status 设置为 permit 许可，生产者消费者模式，acquire 会消耗许可，release 会释放令牌，可以用来控制并发数
>
> `CountDownLatch`  闭锁，当 status = 0的时候，线程才可以继续执行，起到并发控制的作用
>
> `CyclicBarrier`，栅栏，闭锁的升级版，可以控制多个线程在都到达指定位置后，才执行给定的操作（这个操作是 `CyclicBarrier`指定的)，并且可以复用。
>
> 当四个线程都到达barrier状态后，会从四个线程中选择一个线程去执行Runnable。
>
> 
>
> 上面闭锁和栅栏的功能，可以交给 `compleFuture` 来替代
>
> 

